# Vue框架学习 - 第4天

## 课堂反馈



## 知识回顾

axios 是什么？
> 1. Vue专注于网络请求的一个轻量库，就是用来发请求，没有操作DOM的功能
> 2. 调用方式
>    1. axios.get( url ).then( res => {} ).catch( err => {} )
>    2. axios.post( url , data ).then( res => {} ).catch( err => {} )
> 3. 注意在成功或者失败时使用箭头函数声明回调函数，确保函数内部this指向当前vue实例对象

vue基础过渡动画是如何实现的？
> 1. 单个元素动画
>    1. 使用 transition包裹当前需要执行动画的元素，定义name属性，也可以定义tag属性
>    2. 触发条件是 v-if 、v-show 显示或者隐藏元素
>    3. 配合6个class类名对应的css3动画效果最终实现动画效果，class类名使用前面定义的name属性作为前缀，默认是使用 v- 作为前缀
>    4. 6个class类名是根据动画执行的过程动态的添加和移除实现效果的
>    5. 学习了animate.css动画库，注意按需引入 https://daneden.github.io/animate.css/
> 2.  分组元素动画
>    1. 使用transition-group包裹当前需要执行动画的分组元素，定义name属性，也可以定义tag属性
>    2. 内部分组元素使用 v-for 进行循环遍历，需要定义 :key="index" 属性
>    3. 触发条件是添加或者移除某个元素的过程
>    4. 和单个元素动画实现原理一致，都是配合6个class类名对应的css3动画效果最终实现动画效果，class类名使用前面定义的name属性作为前缀，默认是使用 v- 作为前缀
>    5. 和单个元素动画实现原理一致，6个class类名是根据动画执行的过程动态的添加和移除实现效果的

![](.\assets\transition.png)

## 课程目标

- 能够开发让文本框获得焦点的自定义指令
- 能够使用$refs操作DOM
- 能够使用Vue.component注册全局组件
- 能够说出单页应用的优缺点
- 能够使用路由切换不同组件



## vue自定义指令基础学习

1. 什么是vue自定义指令？

   > 前面咱们已经学过，vue有很多已经封装好的指令，提供对应的功能给我们使用，比如：v-text、v-bind、v-on等等，那么，vue提供给我们自己封装指令的方法就叫做自定义指令。
   >
   > 自定义指令在实际开发中使用的频率非常非常小，大家先了解一些最基础的使用即可，我们今天的目标就是：完成一个让输入文本框自动获得焦点的自定义指令

2. 如何定义及使用vue自定义指令？

   > 1. 自定义指令的定义，使用关键字 directives ，directives是一个对象，和el、data、methods、filters、computed等平级
   > 2. directives内部声明一个自定义指令和声明一个对象非常相似，这个对象名是自己命名即可，调用的时候直接使用 v-方法名 就可以调用了
   > 3. 自定义指令在作为属性插入到页面中的过程中，会有三个钩子函数，分别为 bind 、inserted、update
   > 4. 我们目前只需要学会基础使用 inserted 这个钩子函数即可，顾名思义，插入节点的意思，也就是当前属性插入其所在的HTML所在的节点完成以后调用的钩子函数
   > 5. 自定义指令其实就是一个方法，这个方法可以接受一个参数 el 这个参数，代表指令所绑定的元素，可以用来直接操作指令作为属性所在的HTML标签节点DOM元素

``````js
const app = new Vue({
        el: "#app",
        data: {

        },
        // 自定义指令，可以用v-的方式直接使用
        directives: {
            // 定义一个名称 调用的时候 使用 v-focus 即可实现使用
            focus: {
            /* 
            当被绑定的元素插入到 DOM 中的时候，会自动调用这个回调函数，也叫做钩子函数
            inserted，插入节点的意思，也就是当前属性插入其所在的HTML所在的节点完成以后调用的钩子函数
            el: 指令所绑定的元素，可以用来直接操作指令作为属性所在的HTML标签节点DOM元素
            */
                inserted: function (el) {
                    // 聚焦当前调用的元素
                    el.focus()
                }
            }
        }
})
``````



## iScroll平滑滚动插件

> 昨天咱们学习的音乐播放器列表只显示了一部分数据，不能滚动，如果咱们要允许其滚动，我们可以将css改成overflow:auto后，发现有了一个浏览器内置的滚动条，感觉这个滚动条不是特别美观，有没有什么办法可以解决这个问题呢？今天咱们学习一个在企业中使用频率还算是不错的插件叫做平滑滚动插件 iScroll，我们先设置一个类似的简单场景一步一步的带着大家学习使用这个插件的基本功能

1. iScroll平滑滚动插件是什么？[中文文档](http://caibaojian.com/iscroll-5/)

2. iScroll滚动插件都有什么使用场景呢？

   > 1. 我们设置一个 `div>ul>li{这是第$个Li元素}*20 ` 的三层盒子，给div盒子设置一个固定高度以及一个边框
   > 2. 如果div盒子内部的元素希望能够滚动则需要给css设置一个 `overflow:auto ` 的属性，如果我们希望不出现滚动条则需要设置  `overflow:hidden ` ，但是又无法滚动或者拖动了
   > 3. 怎么样才能即不出现滚动条，又能实现滚动或者拖动呢？类似这种三层结构下就需要使用iScroll来实现我们想要的目的了

3. iScroll滚动插件如何使用？

   > 1. 最外层元素div的高度要固定，给div设置一个高度和一个边框，并设置 `overflow:hidden ` 
   > 2. 导入iScroll这个包
   > 3. 创建一个iScroll对象，参数是最外层的div元素即可
   > 4. 设置一个按钮，动态添加li元素，发现这个时候再进行滚动的时候，新添加的元素无法滑动到底了
   > 5. 需要在动态添加li元素，内容更新了之后需要通过`refresh()`通知库，内容更新了，重新计算尺寸

```html
<script src="./lib/iscroll.js"></script>
<script>
  // 直接获取DOM元素，并作为参数直接传给IScroll
  const wrapper = document.querySelector('#wrapper')
  const myScroll = new IScroll(wrapper)
  // IScroll内置基础选择器功能，直接选择元素即可
  const myScroll = new IScroll('#wrapper')
</script>
```

```js
var myScroll = new IScroll('#wrapper');
window.document.getElementsByTagName("button")[0].onclick = function(){
	const li = document.createElement("li");
    li.innerHTML = "我是动态新添加的li元素";
    document.getElementsByTagName("ul")[0].appendChild(li);
    myScroll.refresh();
}
```



## Vue生命周期钩子 - mounted

> 在vue中进行使用iScroll平滑滚动插件，在**vue实例化之前引用**发现引用失败了，打断点发现失败的原因是：Vue还没有解析内置的标签，HTML的DOM结构还没有被Vue渲染完成；我们将iScroll插件放在**vue实例化代码之后引用**，发现能够正常使用了，不过，这个时候假如是一万个li标签异步渲染比较慢，是不是无法确保iScroll绝对能够被成功引用？那该怎么办？

mounted生命周期钩子函数如何使用？[生命周期图示](https://cn.vuejs.org/v2/guide/instance.html#生命周期图示)

> 1. 声明方法，直接使用mounted声明一个函数即可
> 2. 执行时机，vue把内部的data和页面的内容初始化完毕并渲染挂载到页面上之后，自动执行mounted生命周期钩子函数
> 3. mounted使用频率还是很高的，当我们碰到需要获取Vue解析的页面的DOM元素节点的时候，基本上都会写在这个钩子函数里
> 4. mounted只会执行一次，就是HTML结构被Vue完全渲染挂载完成后
> 5. 如果data内部的数据发生改变后，DOM被更新后，则需要使用updated这个钩子函数了，updated这个钩子函数会被多次执行



## $refs属性

> 在vue中调用iScroll，需要传入一个DOM节点对象，我们使用的是document.getElementByID()，这个方式获取的，在复杂的节点结构中，我们使用原生JS操作是不是要考虑很多兼容性？并且显得也非常不便捷！那么我们该如何解决这个问题呢？

Vue给我们提供了一个专门用来获取DOM节点的方法 ，使用元素的ref属性，使用起来非常方便

> 1. 给要获取的元素添加ref属性，名字随便起：有意义即可
> 2. 通过`vue实例.$refs.属性名`即可获取标记的元素，我们在mounted钩子函数中调用可以直接使用this指向当前vue实例，这个才是vue推荐的元素获取方式
> 3. 如果ref重名后面的会吧前面的覆盖



## 播放器歌曲及评论列表平滑滚动优化

> IScroll平滑滚动插件使用，第一个参数是当前DOM节点，第二个参数是对应的参数 [IScroll基础配置](http://caibaojian.com/iscroll-5/config.html)

``````js
this.myScroll = new IScroll('.comment_list', {
    //是否支持鼠标滚动
	mouseWheel: true,
    //是否显示滚动条
	scrollbars: true
})
``````



## Vue组件的基本使用

> 我们前面学习了vue提供的自定义指令的简单使用，vue自定义指令是给html元素添加一个以v-开头的特殊属性实现我们想要的效果
>
> 那么，有没有将多个我们期望的html元素标签组合在一起，然后形成一个我们自定义的标签来进行使用呢？这样的话，我只需要敲一个 标签名，就可以渲染我们期望的标签组合了

1. vue组件的意义是什么？

   > 1. 我们前往京东首页去看看 ，https://www.jd.com/，这个页面上的搜索输入框是不是在很多地方都使用到了？如果按照咱们之前的开发方法是不是通过复制粘贴的方式来进行？有多少处，就复制粘贴多少处？这种方法是不是很low？
   > 2. 现在我们构建一个标签组合，期望这个标签组合能够一次声明多次复用，一次修正全部生效，怎么办？
   > 3. vue给我们提供了一个非常便捷的方法，叫 **组件** 封装，我们将  这些标签的组合  封装成为一个组件，在需要重复调用的之后，直接调用组件即可，定义一次随处使用，一改全部一起改，非常强大

2. vue组件是如何声明使用的呢？

   > 1. 我们先去官网简单的看一下  [组件基础](https://cn.vuejs.org/v2/guide/components.html)
   > 2. 组件的注册 Vue.component( '组件名' , { 参数 } )
   > 3. 在页面中调用，直接把 组件名 当作标签使用即可，一般我们使用驼峰式命名的方式进行声明，使用-拼接方式进行调用
   > 4. 参数中需要声明一个 template 属性，用来保存 html的组合标签，可以使用``包裹字符串来进行声明属性，但是体验很不好，不推荐
   > 5. 抽取组合标签，用模板 script type='html/text' id="item" 进行声明，然后给template直接传参template:"#模板id"，即可实现调用，推荐使用这种方法
   > 6. 需要注意的是：组合标签必须有一个外围的包裹元素，只能有一个父节点，可以有多个子节点



##Vue组件的data和methods定义

1. 我们在组件的声明过程中，是如何声明data和methods的呢？

> 2. 声明methods和之前的没有区别，调用也是一样的调用
> 3. 声明data发生了变化，我们之前是使用对象直接声明的，data在组件内部的声明是使用**函数返回**的方式来进行声明的，调用和之前的调用方法一样，没有区别

```js
data: function() {
	return {
		message: '阿尼阿瑟哟,欧巴！'
	}
},
methods:{
    sayHello(){
        aletr('你好，Vue！')
    }
}
```

2. Vue组件 - data属性为什么用函数声明？

> 在组件中如果不是使用函数返回的方式进行data声明，则所有组件都引用同一份数据对象，任何一个组件修改了数据，所有引用数据的其他组件，都同步更新，互相干扰

![](.\assets\Snipaste_2019-08-12_16-35-11.png)

> 如果在组件中使用函数返回值进行声明data属性，则在每次调用当前组件的时候，都会执行这个函数，返回一个组件独有的数据对象，可以有效的保证互不干扰

![](.\assets\Snipaste_2019-08-12_16-34-27.png)







##SPA单页应用基础理解

1. 什么是SPA单页应用？

   > 1. 我们打开[网易云音乐官网](https://music.163.com/)，我们发现切换路由并没有刷新页面，只是后面的后缀修改了，页面就实现了切换，并且几乎没有任何等待时间，是不是很酷，这个叫什么呢？前端路由，你完全可以先把这个理解为一个高级的tab选项卡
   > 2. 我们也将使用这种前端路由构建的应用叫做SPA单页面应用，第一次进入页面时会请求一个`html`文件，切换到其他组件，此时路径也相应变化，但是并没有新的`html`文件请求，页面内容却变化了。
   > 3. single-page application是一种特殊的Web应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML（采用的是div切换显示和隐藏），从而实现UI与用户的交互。

2. 单页面应用的原理是什么？

   > **原理：** `js`会感知到`url`的变化，通过这一点可以用`js`动态地将当前页面的内容清除，然后将下一个页面的内容挂载到当前页面上。这个时候的路由不再是后端来做了，而是前端来做，判断页面显示相应的组件，清除不需要的，我们也可以先把这个理解为一个高级的tab选项卡

3. 单页应用有什么优缺点？

   |                         | 多页面应用模式MPA                                     | 单页面应用模式SPA                                            |
   | :---------------------- | :---------------------------------------------------- | ------------------------------------------------------------ |
   | **应用构成**            | 由多个完整页面构成                                    | 一个外壳页面和多个页面片段组件构成                           |
   | **跳转方式**            | 页面之间的跳转是从一个页面到另一个页面                | 一个页面片段删除或隐藏，加载另一个页面组件并显示。<br />组件间的模拟跳转，没有外壳页面 |
   | **URL模式**             | `http://xxx/page1.html`<br/>和`http://xxx/page2.html` | `http://xxx/shell.html#page1`<br/>`http://xxx/shell.html#page2` |
   | **用户体验**            | 页面间切换加载慢，不流畅，用户体验差，尤其在移动端    | 页面片段间切换快，用户体验好，包括移动设备                   |
   | **搜索引擎优化（SEO）** | 支持度高                                              | 支持度低，需要专门做SSR服务端渲染                            |



## Vue路由的基本使用  



> 1. 前面我们学习了组件，组件被声明后可以被多次互不干扰的复用，现在我们需要实现一个目标是：**按需切换显示加载我们声明的组件**，该如何实现呢？之前，我们想实现这种切换效果使用的方法是 tab 选项卡显示隐藏的方法来实现的。
> 2. 这种按需加载显示组件，我们也称作为是：**前端路由实现**，我们需要引入一个新的工具Vue Router，你也可以把这个前端路由实现理解为一个更高级的tab选项卡，我们去官网看一下这个前端路由到底是什么东东？[官网地址](https://router.vuejs.org/zh/)
> 3. Vue Router 前端路由的基础使用，实现图片切换的效果
>    1. vueRouter路由并没有集成到vue中,不是所有的项目都会用到路由
>    2. 所以我们先导包vueRouter到项目中
>    3. 用包
>       1. 先进行组件声明,准备好组件
>       2. 路由声明
>          1. 声明路由，每个路由应该映射一个组件
>          2. path 代表我们自定义一个标识,这个标识在需要的地方使用
>          3. 创建路由对象
>          4. 挂载路由
>       3. 路由调用

```html
<div id="app">
  <p>
    <!-- 使用 router-link 组件来导航. -->
    <!-- 通过传入 `to` 属性指定链接. -->
    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
    <router-link to="/foo">这里换一个图片</router-link>
    <router-link to="/bar">这里换一个图片</router-link>
  </p>
  <!-- 路由出口 -->
  <!-- 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>
<!--导包，需要注意先导入vue框架，再导入vue-router插件-->
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
<script>
// 1. 声明路由需要使用到的组件
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }
// 2. 声明路由，每个路由应该映射一个组件
const routes = [
	{ path: '/foo', component: Foo },
	{ path: '/bar', component: Bar }
]
// 3. 创建 router 实例，然后传 `routes` 配置
const router = new VueRouter({
    // (缩写) 相当于 routes: routes，这个名字是固定的
    routes 
})
// 4. 将声明好的router挂载进vue中就可以被调用了
const app = new Vue({
  router
}).$mount('#app')
</script>
```



## 黑云播放器的简单整合实现路由切换

1. 实现最终效果演示
2. 实现步骤分析
3. 代码结构演示
4. 开发过程演示
5. 所用知识及注意事项小结



## 今日课程小结

- 能够开发让文本框获得焦点的自定义指令
- 能够使用$refs操作DOM
- 能够使用Vue.component注册全局组件
- 能够说出单页应用的优缺点
- 能够使用路由切换不同组件