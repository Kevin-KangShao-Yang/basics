<!--
 * @Description: In User Settings Edit
 * @Author: your name
 * @Date: 2019-08-11 09:36:05
 * @LastEditTime: 2019-08-11 09:49:02
 * @LastEditors: Please set LastEditors
 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>

        /* 
        本小节内容; 介绍混合式封装思路
        
         */
        /**
         * @description: 混合式继承封装
         * @param {type} method : 子对象构造函数
         * @param {type} father : 父对象
         * @return: 
         */ 
        function extend(method,father){
            for (var key in father){
                method.prototype[key] = father[key]
            }
        };
        

        //父对象
        var wangjianlin = {
            hourse: {
                address: '北京一环',
                price: 100000000000,
            },
            car: {
                pinpai: '劳斯莱斯',
                price: 8000000
            }
        };

        /* 
        3. 混合式 ： 混入 + 替换原型
        解决方案 ： 遍历父对象成员，添加到子对象构造函数原型种
        */

        function SonWang(name, gfs) {
            this.name = name;
            this.gfs = gfs;
        };

        //每一个儿子有自己的方法：花钱
        SonWang.prototype.flowerMoney = function () {
            console.log('我是wangjianlin的儿子，我很快花钱请女孩子吃麻辣烫');
        };
        //遍历父对象成员，添加到子对象构造函数原型中
        // for (var key in wangjianlin) {
        //     SonWang.prototype[key] = wangjianlin[key];
        // };
        extend(SonWang,wangjianlin);


        var congcong = new SonWang('匆匆', ['雪梨', '豆得儿', '林更新', 'xjh']);
        console.log(congcong);
        console.log(congcong.hourse);



        var xjh = new SonWang('恒恒', ['小苍苍', '左膀', '右臂']);
        console.log(xjh);
        console.log(xjh.car);

    </script>
</body>

</html>