## mobile-day07

### 1.0 概述

#### 1.1 复习

+ dayjs 的使用
  + 下载
  + 引用
  + 相对时间
    + 引用插件
    + 使用插件
  + 语言包：
    + 导入中文语言包
    + 使用语言包
  + 使用相对时间
  + 使用 dayjs 定义一个过滤器，来处理日期的显示格式
+ 更多操作
  + 将更多操作面板封装为一个组件
    + v-model 在组件中的使用
  + 隐藏文章
    + 得到要隐藏和文章数据
    + 得到所有显示的文章数据源
    + 将要隐藏的数据从文章数据源中移除
    + 判断是否登录：
      + 如果登录将要隐藏的文章标记不为喜欢
  + 举报文章
    + 给所有的举报选项添加点击事件
    + 得到要举报的文章
    + 将要举报的文章的id提交到服务器
    + 提示用户举报成功
    + 关闭面板
  + 拉黑作者
    + 给拉黑作者添加点击事件
    + 得到要拉黑的文章数据
    + 将文章的作者提交到服务器接口
    + 提示用户拉黑成功
    + 关闭面板
+ 搜索
  + 组件&路由
  + 入口设置
  + 结构&样式
  + 功能：
    + 输入关键字点击完成进入搜索列表页面
    + 点击取消清空输入框
    + 输入内容产生联想
    + 点击联想内容跳转到搜索列表
    + 给联想框中的搜索关键字添加样式
    + 清空输入框中的内容时自动清除联想框中的内容

#### 1.2 今日内容

+ 前置知识点 ：
  + js 的抖动
    + 防抖
    + 节流
+ 搜索
  + 使用防抖处理输入框中的内容
  + 搜索历史
    + 将搜索的数据进行保存
    + 将搜索的数据进行渲染
    + 将搜索的数据进行操作
      + 删除
      + 排序
      + 去重
    + 点击历史跳转到搜索页面
+ 搜索列表
  + 路由&路由
  + 完成结构&样式
  + 动态请求数据
  + 动态渲染数据
+ 登录验证
  + 判断用户是否登录
  + 将判断的方法封装为一个单独的插件
  + 判断 token 是否失效
    + 如果失效：使用 refresh_token 来更新 token



### 2.0 前置知识点

#### 2.1 js 的抖动

+ 在 js 中经常会出现这样的情况：当页面的滚动条发生滚动&当前窗口大小发生改变&当输入框中的内容发生了改变....
+ 在以上情况中可以触发一些事件：在事件中可以进行逻辑处理（eg: 发送网络请求）
+ 问题：如果在以上事件中进行逻辑处理，将来逻辑处理的执行会反复执行。因为我们在触发以上事件时， 触发的频率太高了
+ 解决方案：
  + 防抖
  + 节流

##### 2.1.1 防抖

+ 作用：

  + 由于 js 中经常会出现抖动的情况，为了优化代码。可以使用防抖来解决抖动问题。

+ 思想：

  + 当触发停止一段时间后，我们才执行逻辑代码
  + 当持续触发事件时，我们不执行逻辑代码，

+ 代码的实现

  ```
      function fangdou(cd, wait) {
          // 定义一个定时器
          let timer;
          // 返回一个函数
          return function() {
              // 清除定时器
              clearTimeout(timer)
              // 定义定时顺
              timer = setTimeout(function() {
                  cd()
              }, wait);
          }
      }
  ```

##### 2.1.2 节流

+ 作用：也是用来解决 js 的抖动问题

+ 思想：

  + 当持续触发事件时，我们依旧会每隔一段时间执行一次逻辑代码

+ 代码

  + 核心代码

    ```
        function jieliu(cb, wait) {
            // 记录一个开始的时间
            let beginTime = Date.now()
            return function () {
                // 记录当前时间
                let currentTime = Date.now()
                // 计算两时间之间的差
                let space = currentTime - beginTime
                // 判断是否大于时间间隔
                if (space >= wait ) {
                    // 要执行一次
                    cb()
                    // 重新记录开始时间
                    beginTime = Date.now()
                }
            }
        }
    ```

  + 完整代码

    ```
        function jieliu(cb, wait) {
            // 记录一个开始的时间
            let beginTime = Date.now()
            let timer
            return function () {
                // 清除定时器
                clearTimeout(timer)
                // 记录当前时间
                let currentTime = Date.now()
                // 计算两时间之间的差
                let space = currentTime - beginTime
                // 判断是否大于时间间隔
                if (space >= wait ) {
                    // 要执行一次
                    cb()
                    // 重新记录开始时间
                    beginTime = Date.now()
                } else {
                    timer = setTimeout(() => {
                        cb()
                    }, wait)
                }
            }
        }
    ```

#### 2.2 set 的使用

+ 是什么

  + es6 中提供的一个新的对象

+ 有什么用

  + 可以用来进行数组的去重

+ 怎么用

  ```js
  var newArr = [...new Set(arr)]
  ```

  

### 3.0 搜索

#### 3.1 解决输入框中的抖动问题

+ 使用 js 的防抖来解决
  + 持续触发时 ，不会执行，停止一段时间后才会继续执行

#### 3.2 搜索历史

+ 完成搜索历史的结构与样式

+ 保存搜索历史

  + 将来搜索内容时，需要将数据保存到 localstorage 中
  + 打开页面进，从 localstorage 中取出数据

+ 渲染搜索历史

  + 得到了搜索历史
  + 将搜索历史进行渲染

+ 操作搜索历史

  + 去重
  + 排序
  + 删除
    + 给叉叉添加一个点击事件
    + 在事件中
      + 传入点击元素的下标
      + 根据下标去数据源中删除数据
      + 将数据重新保存到本地
  + 清除删除历史
    + 给删除历史添加一个点击事件
    + 在事件中
      + 将数据源清空
      + 在本地删除对应的localstorage 
  + 点击历史进入搜索页面
  + 当有联想内容时不显示搜索历史

   

### 4.0 搜索列表

#### 4.1 静态页面

+ 组件&路由
+ 入口 
+ 完成静态页面

#### 4.2 动态请求数据&渲染

+ 打开页面时
  + 得到用户传入的搜索关键字
  + 根据关键字请求服务器得到数据
    + 服务器接口
      + url： /v1_0/search 
      + method： GET 
      + 参数
        + QUERY
          + page 当前页
          + per_page 页容量
          + q  搜索的关键字
  + 将数据渲染到页面上

#### 4.3 完成分页操作

+ 使用 vant 中的 list 组件来改造项目的结构
+ 将请求数据的方法添加到 List 的 load 事件中
+ 解决 bug
  + 默认请求的第二页 bug
  + 每次触底请求两页数据的 bug
+ 设置 list 组件的数据请求的完结状态
+ 下拉刷新
  + vant 中的组件 pullrefresh

#### 4.4 添加登录判断

+ 基本判断
  + 1）从 store 中取出用户信息
  + 2）判断数据是否存在
    + 如果不存在，跳转到登录页面，进行登录
    + 如果存在，直接评论
+ 将登录判断封装到一个全局方法中
  + 在 main.js 中的 Vue 实例中添加一个方法：
    + 登录验证：
      + 1）从 store 中取出用户信息
      + 2）判断数据是否存在
        + 如果不存在，跳转到登录页面，进行登录
          + 并且返回 bool 值 false
        + 如果存在，直接评论
          + 并且返回 bool 值 true

+ 将登录判断封装到一个 vue 的插件中

  + 前置知识点：

    + vue 插件的封装

      + 插件的定义

        ```js
        var plugs = {}
        // 这个对象中一定要有一个方法 
        plugs.install = function(Vue) {  // Vue 的构造器
        	Vue.prototype.$http = axios
        }
        ```

        

      + 插件的使用

        ```js
        import Vue from 'vue'
        import Plugs from './plugs'
        Vue.use(Plugs)
        ```

+ 解决经典 bug

  + bug 说明：

    + 由于点赞时没有登录，要跳转到登录页面，所以登录成功后还需要重新返回进行点赞，所以登录成功后跳转的方式用的是  back
    + 如果是 back 会产生问题：将来打开浏览器直接访问 login时，这时候 back 方式就会出问题

  + 解决方案：

    + 将判断登录与直接登录的路由分开：

      + 将来在定义路由时定义两个路由

        ```
        let router = new Router({
        	routes: [
        		{ path: '/login', component: login }, // 处理普通的用户登录
        		{ path: '/login/nologin', component: login } // 处理登录验证的登录
        	]
        })
        ```

    + 步骤：

      + 1）在 router.js 中的添加另一个路由
      + 2）在验证登录时，不再跳转到 /login 下，而是跳转到 /login/nologin 中
      + 3）在 login.vue 中进行跳转时判断
        + 如果当前路径是 ：/login 
          + 通过 this.$router.push('/home')
        + 如果当前路径是：/login/nologin
          + 通过 this.$router.back()

#### 4.5 登录的过期：

+ bug 说明：
  + 头一天做项目，已经登录过了，状态是记录的。到了第二天过来发现代码第一次打开会报错。
+ 具体原因：
  + 登录的状态是用 token 来保存的
    + token 有自己的特点：
      +  有效期2小时 
+ 解决办法：
  + 使用： refresh_token 
    + token ： 用来保存登录状态
      + 有效期2小时
    +  refresh_token ：用来更新的 token
      + 有效期14天
  + 将来检测 token 是否过期
    + 如果过期就使用服务器中提供的一个接口：
      + url:  /v1_0/authorizations 
      + metod:  PUT 
      + 参数：
        +  **Headers** 
          + Authroizations：refresh_token 
      + 返回值
        + 新的用户 token

### 扩展

#### e1. error 中的属性：

+ config
  + 本次请求服务器所有的请求信息
+  response ：服务器响应的回来的数据
  + config : 本次请求服务器所有的请求信息
  + status：服务器返回的状态





